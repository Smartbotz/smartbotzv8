import { proto, MessageUpdateType } from '@adiwajshing/baileys'
import fs from 'fs'
import path from 'path'
import { config } from '../lib/config'
import { SocketClient } from '../lib/socket'
import { ICommand } from '../Types/command'
export async function handler(upsert: { messages: proto.IWebMessageInfo[]; type: MessageUpdateType }, client: SocketClient) {
  try {
    const m = client.socketMessage(upsert.messages)
    console.log(JSON.stringify(upsert, null, 2))
    if (!m) return
    if (m.type == 'protocolMessage' || m.type == 'senderKeyDistributionMessage') return
    if (!m.text) return
    const mdata = m.isGroup ? await client.socket.groupMetadata(m.chat) : undefined
    const user = mdata?.participants.find((v) => v.id == m.sender.id)
    const botNumber = client.decodeJid(client.socket.user.id)
    const bot = mdata?.participants.find((v) => v.id == botNumber.user + '@' + botNumber.server)
    const isBotAdmin = bot?.admin == 'admin' || bot?.admin == 'superadmin' || false
    const isAdmin = (m.isGroup && user?.isAdmin) || user?.admin == 'superadmin' || false
    const isOwnerGroup = isAdmin ? user?.admin == 'superadmin' : false || false
    const isOwner = config.owner.includes(m.sender?.id) || false
    const commandFile = path.join(__dirname, '..', 'command')
    const commandFilter = (file: string) => /\.ts$/.test(file)
    const sepeg = fs.readdirSync(commandFile).filter(commandFilter)
    for (let file of sepeg) {
      if (!global.cmd[file]) continue
      let commands: ICommand = global.cmd[file]?.handler
      if (!commands) continue
      const prefixRegex = new RegExp('^[' + '‎xzXZ/i!#$%+£¢€¥^°=¶∆×÷π√✓©®:;?&.\\-'.replace(/[|\\{}()[\]^$+*?.\-\^]/g, '\\$&') + ']')
      const str2Regex = (str: string) => str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
      let _prefix = commands.customPrefix ? commands.customPrefix : client.prefix ? client.prefix : prefixRegex
      let match = (
        _prefix instanceof RegExp // RegExp Mode?
          ? [[_prefix.exec(m.text), _prefix]]
          : Array.isArray(_prefix) // Array?
          ? _prefix.map((p) => {
              let re =
                p instanceof RegExp // RegExp in Array?
                  ? p
                  : new RegExp(str2Regex(p))
              return [re.exec(m.text), re]
            })
          : typeof _prefix === 'string' // String?
          ? [[new RegExp(str2Regex(_prefix)).exec(m.text), new RegExp(str2Regex(_prefix))]]
          : [[[], new RegExp(' ')]]
      ).find((p) => p[1])
      if (commands.isEvent) if (commands(m, { jamal: client, match, groupMetadata: mdata, command: file })) continue
      if (typeof commands !== 'function') continue
      let prefix: string
      if ((prefix = (match[0] || '')[0])) {
        const ignooreprefix = m.text.replace(prefix, '')
        let [command, ...args] = ignooreprefix
          .trim()
          .split(' ')
          .filter((a) => a)
        const text = ignooreprefix.trim().split(' ').slice(1).join(' ')
        command = (command || '').toLowerCase()
        const isAccepted =
          commands.command instanceof RegExp
            ? commands.command.test(command)
            : Array.isArray(commands.command)
            ? commands.command.some((cmdp: RegExp | string) => {
                cmdp instanceof RegExp ? cmdp.test(command) : cmdp.toLowerCase() == command
              })
            : typeof commands.command === 'string'
            ? commands.command.toLowerCase() == command
            : false
        if (!isAccepted) continue
        if (m.isBaileys) continue
        console.log('\x1b[36m%s\x1b[0m', `${m.sender?.id} (${m.sender?.name}) ${m.type} ${m.isGroup ? `in ${mdata.subject}` : `Private Chat`} ${command} ${text}`)
        m.command = file
        if (commands.isOwnerGroup && !isOwnerGroup) {
          m.reply(`You are not allowed to use this command. Only owner group can use this command.`)
        }
        if (commands.isAdmin && !isAdmin) {
          m.reply('You are not an admin of this group.')
          continue
        }
        if (commands.isBotAdmin && !isBotAdmin) {
          m.reply('Bot is not an admin of this group.')
          continue
        }
        if (commands.isOwner && !isOwner) {
          m.reply('You are not the owner of  Bot.')
          continue
        }
        if (commands.isGroup && !m.isGroup) {
          m.reply('This command is only for group.')
          continue
        }
        if (commands.isPrivate && !m.isGroup) {
          m.reply('This command is only for private.')
          continue
        }
        try {
          await commands(m, { args: args, command: command, groupMetadata: mdata, jamal: client, prefix: prefix })
          m.react('✅')
        } catch (error) {
          console.error(error)
          m.react('❌')
          m.reply('Error On Command: ' + error)
        }
      }
    }
  } catch (e) {
    console.error(e)
  }
}
