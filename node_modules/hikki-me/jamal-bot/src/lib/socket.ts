import { WASocket, AnyMessageContent, jidDecode, MiscMessageGenerationOptions, proto, downloadContentFromMessage, generateForwardMessageContent, generateWAMessageFromContent } from '@adiwajshing/baileys'
import { ImakeInMemoryStore, IMessage } from '../Types'
import logger from '@adiwajshing/baileys/lib/Utils/logger'
import { toBuffer } from '../Utils'
import fs from 'fs'
import { db } from './database'
import path from 'path'
import { Logger } from 'pino'
logger.level = 'trace'
export class SocketClient {
  constructor(public socket: WASocket, public store: any) {
    this.socket = socket
  }
  public prefix: string = undefined || ''
  public storage: ImakeInMemoryStore = this.store
  public logger: Logger = logger
  public decodeJid = (jid: string) => {
    return jidDecode(jid)
  }
  public reply(chatId: string, message: string | AnyMessageContent | Buffer, m: proto.IWebMessageInfo, options?: MiscMessageGenerationOptions) {
    if (typeof message == 'string' && !fs.existsSync(message) && message.length > 100) return this.socket.sendMessage(chatId, { text: message }, { quoted: m, ...options })
    if (message instanceof Buffer) return this.sendFile(chatId, message, { caption: '', fileName: 'jamal-bot' }, { quoted: m, ...options })
    if (typeof message == 'object') return this.socket.sendMessage(chatId, message, { quoted: m, ...options })
    if (typeof message == 'string') return this.socket.sendMessage(chatId, { text: message }, { quoted: m, ...options })
  }
  /**
   * parseMentions
   */
  public parseMention(str: string): string[] {
    return [...str.matchAll(/@([0-9]{5,16}|0)/g)].map((v) => v[1] + '@s.whatsapp.net')
  }
  public db = new db()
  public async sendTButton(chatId: string, isMedia: boolean, text: string, footer: string, button: string[], more?: AnyMessageContent, media?: Buffer | string, options?: MiscMessageGenerationOptions) {
    const mime = isMedia ? await toBuffer(media) : { mime: 'text/plain', buffer: Buffer.from(text, 'utf8') }
    if (!mime) return console.log('Invalid media type')
    if (isMedia && mime.mime == 'image/webp' && mime) return this.reply(chatId, 'Error Ngab', null)
    const asDoc = (isMedia && mime?.mime?.startsWith('application')) || false
    const prepareButton = (button: string[]) => {
      if (button.length == 2) return [{ quickReplyButton: { displayText: button[0], id: button[1] }, index: 0 }]
      if (button.length == 4)
        return [
          { quickReplyButton: { displayText: button[0], id: button[1] }, index: 0 },
          { quickReplyButton: { displayText: button[2], id: button[3] }, index: 1 },
        ]
      if (button.length == 6)
        return [
          { quickReplyButton: { displayText: button[0], id: button[1] }, index: 0 },
          { quickReplyButton: { displayText: button[2], id: button[3] }, index: 1 },
          { quickReplyButton: { displayText: button[4], id: button[5] }, index: 2 },
        ]
      else []
    }
    return this.socket.sendMessage(
      chatId,
      isMedia
        ? {
            [asDoc ? 'document' : mime.mime.split('/')[0]]: mime.buffer,
            caption: text,
            footer,
            templateButtons: prepareButton(button),
            ...more,
          }
        : {
            text: text,
            ...more,
          },
      options
    )
  }
  public async sendTWithUrlButton(chatId: string, isMedia: boolean, text: string, footer: string, button: string[], more?: AnyMessageContent, media?: Buffer | string, options?: MiscMessageGenerationOptions) {
    const mime = isMedia ? await toBuffer(media) : { mime: 'text/plain', buffer: Buffer.from(text, 'utf8') }
    if (!mime) return console.log('Invalid media type')
    if (isMedia && mime.mime == 'image/webp' && mime) return this.reply(chatId, 'Error Ngab', null)
    const asDoc = (isMedia && mime?.mime?.startsWith('application')) || false
    const prepareButton = (button: string[]) => {
      if (button.length == 2) return [{ urlButton: { displayText: button[0], url: button[1] }, index: 0 }]
      if (button.length == 4)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { quickReplyButton: { displayText: button[2], id: button[3] }, index: 1 },
        ]
      if (button.length == 6)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { quickReplyButton: { displayText: button[2], id: button[3] }, index: 1 },
          { quickReplyButton: { displayText: button[4], id: button[5] }, index: 2 },
        ]
      if (button.length == 8)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { quickReplyButton: { displayText: button[2], id: button[3] }, index: 1 },
          { quickReplyButton: { displayText: button[4], id: button[5] }, index: 2 },
          { quickReplyButton: { displayText: button[6], id: button[7] }, index: 3 },
        ]
      else []
    }
    return this.socket.sendMessage(
      chatId,
      isMedia
        ? {
            [asDoc ? 'document' : mime.mime.split('/')[0]]: mime.buffer,
            caption: text,
            footer,
            templateButtons: prepareButton(button),
            ...more,
          }
        : {
            text: text,
            ...more,
          },
      options
    )
  }
  /**
   * send 5 button
   * @param chatId string
   * @param isMedia boolean
   * @param text string
   * @param footer string
   * @param button []
   * @param more ...AnyMessageContent
   * @param media string or buffer
   * @param options options
   * @returns messsage
   */
  public async sendTWithUrlandCallButton(chatId: string, isMedia: boolean, text: string, footer: string, button: string[], more?: AnyMessageContent, media?: Buffer | string, options?: MiscMessageGenerationOptions) {
    const mime = isMedia ? await toBuffer(media) : { mime: 'text/plain', buffer: Buffer.from(text, 'utf8') }
    if (!mime) return console.log('Invalid media type')
    if (isMedia && mime?.mime == 'image/webp' && mime) return this.reply(chatId, 'Error Ngab', null)
    const asDoc = (isMedia && mime?.mime?.startsWith('application')) || false
    const prepareButton = (button: string[]) => {
      if (button.length == 2) return [{ urlButton: { displayText: button[0], url: button[1] }, index: 0 }]
      if (button.length == 4)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { callButton: { displayText: button[2], phoneNumber: button[3] }, index: 1 },
        ]
      if (button.length == 6)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { callButton: { displayText: button[2], phoneNumber: button[3] }, index: 1 },
          { quickReplyButton: { displayText: button[4], id: button[5] }, index: 2 },
        ]
      if (button.length == 8)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { callButton: { displayText: button[2], PhoneNumber: button[3] }, index: 1 },
          { quickReplyButton: { displayText: button[4], id: button[5] }, index: 2 },
          { quickReplyButton: { displayText: button[6], id: button[7] }, index: 3 },
        ]
      if (button.length == 10)
        return [
          { urlButton: { displayText: button[0], url: button[1] }, index: 0 },
          { callButton: { displayText: button[2], PhoneNumber: button[3] }, index: 1 },
          { quickReplyButton: { displayText: button[4], id: button[5] }, index: 2 },
          { quickReplyButton: { displayText: button[6], id: button[7] }, index: 3 },
          { quickReplyButton: { displayText: button[8], id: button[9] }, index: 4 },
        ]
      else []
    }
    return this.socket.sendMessage(
      chatId,
      isMedia
        ? {
            [asDoc ? 'document' : mime.mime.split('/')[0]]: mime.buffer,
            caption: text,
            footer,
            templateButtons: prepareButton(button),
            ...more,
          }
        : {
            text: text,
            ...more,
          },
      options
    )
  }
  public async sendT3Button(chatId: string, isMedia: boolean, text: string, footer: string, button: string[], more?: AnyMessageContent, media?: Buffer | string, options?: MiscMessageGenerationOptions) {
    const mime = isMedia ? await toBuffer(media) : { mime: 'text/plain', buffer: Buffer.from(text, 'utf8') }
    if (isMedia && mime?.mime == 'image/webp') throw new Error('Invalid media type')
    const asDoc = (isMedia && mime?.mime.startsWith('application')) || false
    return this.socket.sendMessage(
      chatId,
      isMedia
        ? {
            [asDoc ? 'document' : mime.mime.split('/')[0]]: mime.buffer,
            caption: text,
            footer,
            templateButtons: [
              button.length == 2
                ? { urlButton: { displayText: button[0], url: button[1] } } // 1 button
                : button.length == 4
                ? { urlButton: { displayText: button[0], url: button[1] }, callButton: { displayText: button[2], phoneNumber: button[3] } } // 2 buttons
                : { urlButton: { displayText: button[0], url: button[1] }, callButton: { displayText: button[2], phoneNumber: button[3] }, quickReplyButton: { displayText: button[4], id: button[5] } },
            ], // 3 button
            ...more,
          }
        : {
            text: text,
            ...more,
          },
      options
    )
  }
  public async send3Button(chatId: string, isMedia: boolean, text: string, footer: string, button: string[], more?: AnyMessageContent, media?: Buffer | string, options?: MiscMessageGenerationOptions) {
    const mime = isMedia ? await toBuffer(media) : { mime: 'text/plain', buffer: Buffer.from(text, 'utf8') }
    if (isMedia && mime?.mime == 'image/webp') throw new Error('Invalid media type')
    const asDoc = isMedia && mime?.mime.startsWith('application')
    const prepareButton = (button: string[]): proto.IButton[] => {
      if (button.length == 2) return [{ buttonText: { displayText: button[0] }, buttonId: button[1] }]
      if (button.length == 4)
        return [
          { buttonText: { displayText: button[0] }, buttonId: button[1] },
          { buttonText: { displayText: button[2] }, buttonId: button[3] },
        ]
      if (button.length == 6)
        return [
          { buttonText: { displayText: button[0] }, buttonId: button[1] },
          { buttonText: { displayText: button[2] }, buttonId: button[3] },
          { buttonText: { displayText: button[4] }, buttonId: button[5] },
        ]
    }
    return this.socket.sendMessage(
      chatId,
      isMedia
        ? {
            [asDoc ? 'document' : mime.mime.split('/')[0]]: mime.buffer,
            caption: text,
            footer,
            buttons: prepareButton(button),
            ...more,
          }
        : {
            text: text,
            ...more,
          },
      options
    )
  }
  public async sendFile(chatId: string, file: string | Buffer, exra?: any, options?: MiscMessageGenerationOptions) {
    const { buffer, mime } = await toBuffer(file)
    let content: AnyMessageContent
    if (mime == 'image/webp') content = { sticker: buffer, ...exra }
    else if (mime.startsWith('image')) content = { image: buffer, ...exra }
    else if (mime.startsWith('video')) content = { video: buffer, ...exra }
    else if (mime.startsWith('audio')) content = { audio: buffer, ...exra, mimetype: 'audio/mpeg' }
    else if (mime.startsWith('application')) content = { document: buffer, ...exra }
    else if (mime.startsWith('text')) content = { text: buffer, ...exra }
    else return console.log('Invalid file type')
    this.socket.sendMessage(chatId, content, options)
  }
  public async download(m: any): Promise<Buffer> {
    if (!m.isMedia) throw new Error('Message is not media')
    const pe = await downloadContentFromMessage(m, m.type.replace('Message', ''))
    let buffer = Buffer.from([])
    for await (const chunk of pe) {
      buffer = Buffer.concat([buffer, chunk])
    }
    return buffer
  }
  public copasDlu(jid: string, message: proto.IWebMessageInfo, forceForward = false, options: any = {}) {
    let vtype: string
    if (options.readViewOnce) {
      message.message = message.message && message.message.ephemeralMessage && message.message.ephemeralMessage.message ? message.message.ephemeralMessage.message : message.message || undefined
      vtype = Object.keys(message.message.viewOnceMessage.message)[0]
      delete message.message.viewOnceMessage.message[vtype].viewOnce
      message.message = {
        ...message.message.viewOnceMessage.message,
      }
    }
    let mtype = Object.keys(message.message)[0]
    let content = generateForwardMessageContent(message, forceForward)
    let ctype = Object.keys(content)[0]
    let context = {}
    if (mtype != 'conversation') context = message.message[mtype].contextInfo
    content[ctype].contextInfo = {
      ...context,
      ...content[ctype].contextInfo,
    }
    const waMessage = generateWAMessageFromContent(
      jid,
      content,
      options
        ? {
            ...content[ctype],
            ...options,
            ...(options.contextInfo
              ? {
                  contextInfo: {
                    ...content[ctype].contextInfo,
                    ...options.contextInfo,
                  },
                }
              : {}),
          }
        : {}
    )
    return this.socket.relayMessage(jid, waMessage.message, { messageId: waMessage.key.id })
  }

  public socketMessage(messages: proto.IWebMessageInfo[]): IMessage {
    try {
      let m = {} as IMessage
      const msg = messages[0].message
      if (!msg) return
      m.type = Object.keys(msg)[0]
      if (m.type === 'protocolMessage' || m.type == 'senderKeyDistributionMessage') return m
      m.sender = {
        name: messages[0].pushName,
        id: messages[0].key?.participant || messages[0].key?.remoteJid,
      }
      m.name = messages[0].pushName
      m.key = messages[0].key
      m.isBaileys = m.key.id?.startsWith('BAE')
      m.isMedia = typeof msg[m.type]?.url == 'string'
      if (m.isMedia) {
        m = { ...msg[m.type], ...m }
      }
      m.isGroup = m.key?.remoteJid?.endsWith('@g.us') ? true : false
      m.chat = messages[0].key.remoteJid
      m.mention = msg[m.type]?.contextInfo?.mentionedJid || []
      m.react = (emoji: string) => this.socket.sendMessage(m.chat, { react: { key: messages[0].key, text: emoji } })
      m.delete = () => this.socket.sendMessage(m.chat, { delete: messages[0].key })
      m.text = msg?.conversation || msg?.imageMessage?.caption || msg?.videoMessage?.caption || msg?.extendedTextMessage?.text || msg?.buttonsResponseMessage?.selectedButtonId || msg?.templateButtonReplyMessage?.selectedId
      m.quoted = msg[m.type]?.contextInfo?.quotedMessage || m?.contextInfo?.quotedMessage || null
      m.download = async () => await this.download(m)
      if (m.quoted) {
        m.quoted = m.quoted
        m.quoted.type = Object.keys(m.quoted)[0]
        m.quoted.text = m.quoted.type == 'conversation' ? m.quoted[m.quoted.type] : m.quoted.type == 'extendedTextMessage' ? m.quoted[m.quoted.type].text : m.quoted.type == 'imageMessage' || m.quoted.type == 'videoMessage' ? m.quoted[m.quoted.type].caption : undefined
        m.quoted = m.quoted.type == 'conversation' ? { text: m.quoted[m.quoted.type], ...m.quoted } : { ...m.quoted[m.quoted.type], type: m.quoted.type }
        m.quoted.isMedia = typeof m.quoted == 'object' && m.quoted?.url ? true : false
        m.quoted.mention = m.quoted.contextInfo?.mentionedJid || []
        m.quoted.id = msg[m.type]?.contextInfo?.stanzaId
        m.quoted.msg = this.storage.messages[m.chat].get(m.quoted.id)
        m.quoted.getMessage = () => this.storage.messages[m.chat].get(m.quoted.id)
        m.quoted.name = m.quoted.msg?.pushName
        m.quoted.key = m.quoted.msg?.key
        m.quoted.react = (emoji: string) => this.socket.sendMessage(m.chat, { react: { key: m.quoted.key, text: emoji } })
        m.quoted.sender = {
          id: this.decodeJid(m.quoted.msg?.key?.participant)?.user + '@' + this.decodeJid(m.quoted.msg?.key?.participant)?.server || this.decodeJid(m.quoted.msg?.key?.remoteJid)?.user + '@' + this.decodeJid(m.quoted.msg?.key?.remoteJid)?.server || '',
          name: m.quoted.msg?.pushName,
        }
        m.quoted.isBaileys = m.quoted.msg?.key.id?.startsWith('BAE')
        m.quoted.getQuoted = () => this.storage.messages[m.chat].get(m.quoted.msg?.message[Object.keys(m.quoted.msg.message)[0]].contextInfo.stanzaId)
        m.quoted.message = m.quoted.msg?.message
        m.quoted.isMedia ? (m.quoted.download = async (): Promise<Buffer> => await this.download(m.quoted)) : ''
        const msgq = this.storage.messages[m.chat].get(m.quoted.id)
        if (msgq) {
          m.quoted.delete = () => this.socket.sendMessage(m.chat, { delete: msgq.key })
          m.quoted.copast = (forceForward = false, options: any = {}) => this.copasDlu(m.chat, m.quoted.getMessage(), forceForward, options)
        }
      }
      m.reply = (text: string | Buffer) => this.reply(m.chat, text, m, { quoted: messages[0] })
      return m
    } catch (e) {
      console.log(e)
    }
  }
}
fs.watch(path.join(__dirname), global.reload)
