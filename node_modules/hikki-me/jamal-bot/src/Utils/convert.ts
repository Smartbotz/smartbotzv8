import fetch from 'node-fetch'
import crypto, { randomBytes } from 'crypto'
import sharp from 'sharp'
import axios from 'axios'
import ffmpeg from 'fluent-ffmpeg'
import fs from 'fs'
import FormData from 'form-data'
import cheerio from 'cheerio'
const Image = require('node-webpmux').Image
const config = {
  sessionInfo: {
    WA_VERSION: '2.2106.5',
    PAGE_UA: 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
    WA_AUTOMATE_VERSION: '3.6.10 UPDATE AVAILABLE: 3.6.11',
    BROWSER_VERSION: 'HeadlessChrome/88.0.4324.190',
    OS: 'Windows Server 2016',
    START_TS: 1614310326309,
    NUM: '6247',
    LAUNCH_TIME_MS: 7934,
    PHONE_VERSION: '2.20.205.16',
  },
  config: {
    sessionId: 'session',
    headless: true,
    qrTimeout: 20,
    authTimeout: 0,
    cacheEnabled: false,
    useChrome: true,
    killProcessOnBrowserClose: true,
    throwErrorOnTosBlock: false,
    chromiumArgs: ['--no-sandbox', '--disable-setuid-sandbox', '--aggressive-cache-discard', '--disable-cache', '--disable-application-cache', '--disable-offline-load-stale-cache', '--disk-cache-size=0'],
    executablePath: 'C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe',
    skipBrokenMethodsCheck: true,
    stickerServerEndpoint: true,
  },
}
type StickerMetaData = {
  author?: string
  pack?: string
  packid?: string
  keepScale?: boolean
  removebg?: string
  circle?: boolean
}
import { generatePath, pathToUrl, toBuffer } from './frontend'

export const setExif = (webpSticker: Buffer, packname: string, author: string, extra = {}): Promise<Buffer> => {
  return new Promise(async (resolve, reject) => {
    const img = new Image()
    const stickerPackId = randomBytes(16).toString('hex').slice(0, 8)
    const json = {
      'sticker-pack-id': stickerPackId,
      'sticker-pack-name': packname,
      'sticker-pack-publisher': author,
      'sticker-pack-publisher-id': author,
      'sticker-pack-version': '1.0.0',
      'android-app-store-link': 'https://hardianto.xyz',
      'ios-app-store-link': 'https://hardianto.xyz',
      'sticker-pack-description': 'sticker ini merupakan sticker yang telah di generate oleh jamal',
      emojis: ['â¤', 'ğŸ˜', 'ğŸ˜˜', 'ğŸ’•', 'ğŸ˜»', 'ğŸ’‘', 'ğŸ‘©â€â¤â€ğŸ‘©', 'ğŸ‘¨â€â¤â€ğŸ‘¨', 'ğŸ’', 'ğŸ‘©â€â¤â€ğŸ’‹â€ğŸ‘©', 'ğŸ‘¨â€â¤â€ğŸ’‹â€ğŸ‘¨', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ’”', 'â£', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–', 'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'â™¥', 'ğŸ’Œ', 'ğŸ’‹', 'ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘©', 'ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ‘©', 'ğŸ‘¨â€â¤ï¸â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨', 'ğŸ‘¬', 'ğŸ‘­', 'ğŸ‘«', 'ğŸ¥°', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ‘„', 'ğŸŒ¹', 'ğŸ˜½', 'â£ï¸', 'â¤ï¸', 'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ™‚', 'ğŸ˜›', 'ğŸ˜', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ¤—', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹', 'â˜º', 'ğŸ˜Œ', 'ğŸ˜‰', 'ğŸ¤—', 'ğŸ˜Š', 'ğŸŠ', 'ğŸ‰', 'ğŸ', 'ğŸˆ', 'ğŸ‘¯â€â™‚ï¸', 'ğŸ‘¯', 'ğŸ‘¯â€â™€ï¸', 'ğŸ’ƒ', 'ğŸ•º', 'ğŸ”¥', 'â­ï¸', 'âœ¨', 'ğŸ’«', 'ğŸ‡', 'ğŸ†', 'ğŸ»', 'ğŸ¥‚', 'ğŸ¾', 'ğŸ‚', 'ğŸ°', 'â˜¹', 'ğŸ˜£', 'ğŸ˜–', 'ğŸ˜«', 'ğŸ˜©', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜', 'ğŸ˜”', 'ğŸ˜Ÿ', 'ğŸ˜•', 'ğŸ˜¤', 'ğŸ˜ ', 'ğŸ˜¥', 'ğŸ˜°', 'ğŸ˜¨', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ˜“', 'ğŸ™â€â™‚', 'ğŸ™â€â™€', 'ğŸ’”', 'ğŸ™', 'ğŸ¥º', 'ğŸ¤•', 'â˜”ï¸', 'â›ˆ', 'ğŸŒ©', 'ğŸŒ§,ğŸ˜¯', 'ğŸ˜¦', 'ğŸ˜§', 'ğŸ˜®', 'ğŸ˜²', 'ğŸ™€', 'ğŸ˜±', 'ğŸ¤¯', 'ğŸ˜³', 'â—', 'â•', 'ğŸ¤¬', 'ğŸ˜¡', 'ğŸ˜ ', 'ğŸ™„', 'ğŸ‘¿', 'ğŸ˜¾', 'ğŸ˜¤', 'ğŸ’¢', 'ğŸ‘º', 'ğŸ—¯ï¸', 'ğŸ˜’', 'ğŸ¥µ', 'ğŸ‘‹'],
      ...extra,
    }
    let exifAttr = Buffer.from([0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
    let jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8')
    let exif = Buffer.concat([exifAttr, jsonBuffer])
    exif.writeUIntLE(jsonBuffer.length, 14, 4)
    await img.load(webpSticker)
    img.exif = exif
    return resolve((await img.save(null)) as Buffer)
  })
}
export const makeSticker = async (file: string | Buffer, datao: StickerMetaData = { author: '', pack: '', keepScale: true, removebg: 'HQ', circle: false }): Promise<Buffer> => {
  return new Promise(async (resolve, reject) => {
    const buffer = await toBuffer(file)
    if (buffer.mime == 'image/webp') return resolve(await setExif(buffer.buffer, datao.pack, datao.author))
    const config2 = {
      ...datao,
      processOptions: {
        crop: !datao.keepScale,
        fps: 10,
        startTime: '00:00:00.0',
        endTime: '00:00:7.0',
        loop: 0,
      },
    }
    const DEFAULT_URL = 'https://sticker-api.openwa.dev/'
    let Type = buffer.mime.includes('image') ? 'image' : 'file'
    let url = String(`${DEFAULT_URL}${Type === 'image' ? 'prepareWebp' : 'convertMp4BufferToWebpDataUrl'}`)
    await axios(url, {
      method: 'POST',
      headers: {
        Accept: 'application/json, text/plain, /',
        'Content-Type': 'application/json;charset=utf-8',
        'User-Agent': 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
      },
      data: JSON.stringify(Object.assign(config, { stickerMetadata: config2 }, { [Type]: `data:${buffer.mime};base64,${buffer.buffer.toString('base64')}` })),
      maxBodyLength: 20000000,
      maxContentLength: 1500000,
    })
      .then(async ({ data }) => {
        if (Type === 'image') return resolve(await setExif(Buffer.from(data.webpBase64, 'base64'), datao.author, datao.pack))
        else {
          const webpBase: string = data.replace(/^data:(.*?);base64,/, '')
          const webpBase64 = webpBase.replace(/ /g, '+')
          const file = Buffer.from(webpBase64, 'base64')
          resolve(await setExif(file, datao.pack, datao.author))
        }
      })
      .catch((err) => reject(err))
  })
}
export function webpToPng(webp: Buffer): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    sharp(webp)
      .png()
      .toBuffer((err, data) => {
        if (err) return reject(err)
        resolve(data)
      })
  })
}
export function removeBg(bufferr: Buffer): Promise<Buffer> {
  return new Promise(async (resolve, reject) => {
    const file = new FormData()
    let { buffer, mime } = await toBuffer(bufferr)
    if (mime.includes('video')) return reject('Video tidak dapat dihapus background')
    if (mime.includes('webp')) buffer = await webpToPng(buffer)
    file.append('image_file', fs.createReadStream(pathToUrl(buffer, mime.includes('webp') ? 'png' : mime.split('/')[1])))
    const raw = await fetch('https://sdk.photoroom.com/v1/segment', {
      method: 'POST',
      headers: {
        'x-api-key': '102279905dd5fd330cfa4d33c0ee13646946d683',
        responseType: 'arraybuffer',
      },
      body: file,
    })
    resolve(raw.buffer())
  })
}
export const toAudio = async (file: Buffer): Promise<Buffer> => {
  return new Promise(async (resolve, reject) => {
    const path = generatePath('mp4')
    const output = generatePath('mp3')
    fs.writeFileSync(path, file)
    ffmpeg({ source: path })
      .toFormat('mp3')
      .save(output)
      .on('error', (err) => reject(err))
      .on('end', () => resolve(fs.readFileSync(output)))
  })
}
export const webpToGif = async (url: string): Promise<{ creator: string; file: string }> => {
  return new Promise(async (resolve, reject) => {
    const form = new FormData()
    const path = fs.existsSync(url) ? fs.createReadStream(url) : url
    form.append('new-image', fs.existsSync(url) ? fs.createReadStream(url) : '')
    form.append('new-image-url', !fs.existsSync(url) ? url : '')
    await axios({
      method: 'post',
      url: 'https://s1.ezgif.com/webp-to-gif',
      data: form,
      headers: {
        'Content-Type': 'multipart/form-data' + '; boundary=' + form.getBoundary(),
        Accept: 'application/json',
      },
    })
      .then((res) => {
        const duit = cheerio.load(res.data)
        const from2 = new FormData()
        const url = 'https://ezgif.com' + duit('#main > form').attr('action')
        const file = url.split('/')[url.split('/').length - 1]
        from2.append('file', file)
        from2.append('convert', 'Convert WebP to MP4!')
        if (!url) return console.log('error')
        axios({
          method: 'post',
          url: url,
          data: from2,
          headers: {
            'Content-Type': 'multipart/form-data' + '; boundary=' + from2.getBoundary(),
            Accept: 'application/json',
          },
        }).then((res) => {
          const $ = cheerio.load(res.data)
          resolve({
            creator: 'hardianto02_',
            file: 'https:' + $('#output > p.outfile > img').attr('src'),
          })
        })
      })
      .catch((err) => {
        console.log(err)
      })
  })
}
