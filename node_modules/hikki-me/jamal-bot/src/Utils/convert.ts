import fetch from 'node-fetch'
import crypto, { randomBytes } from 'crypto'
import sharp from 'sharp'
import axios from 'axios'
import ffmpeg from 'fluent-ffmpeg'
import fs from 'fs'
import FormData from 'form-data'
import cheerio from 'cheerio'
const Image = require('node-webpmux').Image
const config = {
  sessionInfo: {
    WA_VERSION: '2.2106.5',
    PAGE_UA: 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
    WA_AUTOMATE_VERSION: '3.6.10 UPDATE AVAILABLE: 3.6.11',
    BROWSER_VERSION: 'HeadlessChrome/88.0.4324.190',
    OS: 'Windows Server 2016',
    START_TS: 1614310326309,
    NUM: '6247',
    LAUNCH_TIME_MS: 7934,
    PHONE_VERSION: '2.20.205.16',
  },
  config: {
    sessionId: 'session',
    headless: true,
    qrTimeout: 20,
    authTimeout: 0,
    cacheEnabled: false,
    useChrome: true,
    killProcessOnBrowserClose: true,
    throwErrorOnTosBlock: false,
    chromiumArgs: ['--no-sandbox', '--disable-setuid-sandbox', '--aggressive-cache-discard', '--disable-cache', '--disable-application-cache', '--disable-offline-load-stale-cache', '--disk-cache-size=0'],
    executablePath: 'C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe',
    skipBrokenMethodsCheck: true,
    stickerServerEndpoint: true,
  },
}
type StickerMetaData = {
  author?: string
  pack?: string
  packid?: string
  keepScale?: boolean
  removebg?: string
  circle?: boolean
}
import { generatePath, pathToUrl, toBuffer } from './frontend'

export const setExif = (webpSticker: Buffer, packname: string, author: string, extra = {}): Promise<Buffer> => {
  return new Promise(async (resolve, reject) => {
    const img = new Image()
    const stickerPackId = randomBytes(16).toString('hex').slice(0, 8)
    const json = {
      'sticker-pack-id': stickerPackId,
      'sticker-pack-name': packname,
      'sticker-pack-publisher': author,
      'sticker-pack-publisher-id': author,
      'sticker-pack-version': '1.0.0',
      'android-app-store-link': 'https://hardianto.xyz',
      'ios-app-store-link': 'https://hardianto.xyz',
      'sticker-pack-description': 'sticker ini merupakan sticker yang telah di generate oleh jamal',
      emojis: ['❤', '😍', '😘', '💕', '😻', '💑', '👩‍❤‍👩', '👨‍❤‍👨', '💏', '👩‍❤‍💋‍👩', '👨‍❤‍💋‍👨', '🧡', '💛', '💚', '💙', '💜', '🖤', '💔', '❣', '💞', '💓', '💗', '💖', '💘', '💝', '💟', '♥', '💌', '💋', '👩‍❤️‍💋‍👩', '👨‍❤️‍💋‍👨', '👩‍❤️‍👨', '👩‍❤️‍👩', '👨‍❤️‍👨', '👩‍❤️‍💋‍👨', '👬', '👭', '👫', '🥰', '😚', '😙', '👄', '🌹', '😽', '❣️', '❤️', '😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '🙂', '😛', '😝', '😜', '🤪', '🤗', '😺', '😸', '😹', '☺', '😌', '😉', '🤗', '😊', '🎊', '🎉', '🎁', '🎈', '👯‍♂️', '👯', '👯‍♀️', '💃', '🕺', '🔥', '⭐️', '✨', '💫', '🎇', '🎆', '🍻', '🥂', '🍾', '🎂', '🍰', '☹', '😣', '😖', '😫', '😩', '😢', '😭', '😞', '😔', '😟', '😕', '😤', '😠', '😥', '😰', '😨', '😿', '😾', '😓', '🙍‍♂', '🙍‍♀', '💔', '🙁', '🥺', '🤕', '☔️', '⛈', '🌩', '🌧,😯', '😦', '😧', '😮', '😲', '🙀', '😱', '🤯', '😳', '❗', '❕', '🤬', '😡', '😠', '🙄', '👿', '😾', '😤', '💢', '👺', '🗯️', '😒', '🥵', '👋'],
      ...extra,
    }
    let exifAttr = Buffer.from([0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])
    let jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8')
    let exif = Buffer.concat([exifAttr, jsonBuffer])
    exif.writeUIntLE(jsonBuffer.length, 14, 4)
    await img.load(webpSticker)
    img.exif = exif
    return resolve((await img.save(null)) as Buffer)
  })
}
export const makeSticker = async (file: string | Buffer, datao: StickerMetaData = { author: '', pack: '', keepScale: true, removebg: 'HQ', circle: false }): Promise<Buffer> => {
  return new Promise(async (resolve, reject) => {
    const buffer = await toBuffer(file)
    if (buffer.mime == 'image/webp') return resolve(await setExif(buffer.buffer, datao.pack, datao.author))
    const config2 = {
      ...datao,
      processOptions: {
        crop: !datao.keepScale,
        fps: 10,
        startTime: '00:00:00.0',
        endTime: '00:00:7.0',
        loop: 0,
      },
    }
    const DEFAULT_URL = 'https://sticker-api.openwa.dev/'
    let Type = buffer.mime.includes('image') ? 'image' : 'file'
    let url = String(`${DEFAULT_URL}${Type === 'image' ? 'prepareWebp' : 'convertMp4BufferToWebpDataUrl'}`)
    await axios(url, {
      method: 'POST',
      headers: {
        Accept: 'application/json, text/plain, /',
        'Content-Type': 'application/json;charset=utf-8',
        'User-Agent': 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
      },
      data: JSON.stringify(Object.assign(config, { stickerMetadata: config2 }, { [Type]: `data:${buffer.mime};base64,${buffer.buffer.toString('base64')}` })),
      maxBodyLength: 20000000,
      maxContentLength: 1500000,
    })
      .then(async ({ data }) => {
        if (Type === 'image') return resolve(await setExif(Buffer.from(data.webpBase64, 'base64'), datao.author, datao.pack))
        else {
          const webpBase: string = data.replace(/^data:(.*?);base64,/, '')
          const webpBase64 = webpBase.replace(/ /g, '+')
          const file = Buffer.from(webpBase64, 'base64')
          resolve(await setExif(file, datao.pack, datao.author))
        }
      })
      .catch((err) => reject(err))
  })
}
export function webpToPng(webp: Buffer): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    sharp(webp)
      .png()
      .toBuffer((err, data) => {
        if (err) return reject(err)
        resolve(data)
      })
  })
}
export function removeBg(bufferr: Buffer): Promise<Buffer> {
  return new Promise(async (resolve, reject) => {
    const file = new FormData()
    let { buffer, mime } = await toBuffer(bufferr)
    if (mime.includes('video')) return reject('Video tidak dapat dihapus background')
    if (mime.includes('webp')) buffer = await webpToPng(buffer)
    file.append('image_file', fs.createReadStream(pathToUrl(buffer, mime.includes('webp') ? 'png' : mime.split('/')[1])))
    const raw = await fetch('https://sdk.photoroom.com/v1/segment', {
      method: 'POST',
      headers: {
        'x-api-key': '102279905dd5fd330cfa4d33c0ee13646946d683',
        responseType: 'arraybuffer',
      },
      body: file,
    })
    resolve(raw.buffer())
  })
}
export const toAudio = async (file: Buffer): Promise<Buffer> => {
  return new Promise(async (resolve, reject) => {
    const path = generatePath('mp4')
    const output = generatePath('mp3')
    fs.writeFileSync(path, file)
    ffmpeg({ source: path })
      .toFormat('mp3')
      .save(output)
      .on('error', (err) => reject(err))
      .on('end', () => resolve(fs.readFileSync(output)))
  })
}
export const webpToGif = async (url: string): Promise<{ creator: string; file: string }> => {
  return new Promise(async (resolve, reject) => {
    const form = new FormData()
    const path = fs.existsSync(url) ? fs.createReadStream(url) : url
    form.append('new-image', fs.existsSync(url) ? fs.createReadStream(url) : '')
    form.append('new-image-url', !fs.existsSync(url) ? url : '')
    await axios({
      method: 'post',
      url: 'https://s1.ezgif.com/webp-to-gif',
      data: form,
      headers: {
        'Content-Type': 'multipart/form-data' + '; boundary=' + form.getBoundary(),
        Accept: 'application/json',
      },
    })
      .then((res) => {
        const duit = cheerio.load(res.data)
        const from2 = new FormData()
        const url = 'https://ezgif.com' + duit('#main > form').attr('action')
        const file = url.split('/')[url.split('/').length - 1]
        from2.append('file', file)
        from2.append('convert', 'Convert WebP to MP4!')
        if (!url) return console.log('error')
        axios({
          method: 'post',
          url: url,
          data: from2,
          headers: {
            'Content-Type': 'multipart/form-data' + '; boundary=' + from2.getBoundary(),
            Accept: 'application/json',
          },
        }).then((res) => {
          const $ = cheerio.load(res.data)
          resolve({
            creator: 'hardianto02_',
            file: 'https:' + $('#output > p.outfile > img').attr('src'),
          })
        })
      })
      .catch((err) => {
        console.log(err)
      })
  })
}
