import { table } from 'table'
import pkg from '../../package.json'
import fs from 'fs'
import fetch from 'node-fetch'
import filetype from 'file-type'
import axios from 'axios'
import { LoggerLevel } from 'mongodb'
import { tmpdir } from 'os'
import { randomBytes } from 'crypto'
export function printTable(isLatest: boolean, waVersion: any) {
  const data = [
    ['Author :', pkg.author],
    ['Repository :', pkg.repository.url],
    ['Instagram :', '@hardianto02_'],
    ['Github :', 'https://github.com/hardianto02'],
    ['Whatsapp :', 'https://wa.me/62895325697662'],
    ['Gopay :', '62895325697662'],
    ['Reporter :', pkg.bugs.url],
    ['WhatsApp Version :', waVersion],
    ['Name Bot :', 'Jamal Bot'],
    ['Language :', 'typescript'],
    ['Version :', pkg.version],
    ['Latest Version :', isLatest],
  ]
  return table(data)
}
type IExt = 'mp4' | 'mp3' | 'png' | 'jpg' | 'gif' | 'pdf' | 'doc' | 'docx' | 'ppt' | 'pptx' | 'xls' | 'xlsx' | 'txt' | 'zip' | 'rar' | '7z' | 'mp3' | 'm4a' | 'ogg' | 'wav' | 'flac' | 'aac' | 'wma' | 'mka' | 'flac' | 'ape' | 'alac' | 'aiff' | 'aif' | 'wv' | 'm4p' | 'm4b' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2' | 'mp3' | 'mp4' | 'm4a' | 'm4b' | 'm4p' | 'm4r' | 'm4v' | 'mpa' | 'mp2'
export function pathToUrl(buffer: Buffer, ext: string): string {
  let desti = tmpdir() + '/' + randomBytes(10).toString('hex') + '.' + ext
  fs.writeFileSync(desti, buffer)
  return desti
}
export function generatePath(ext: string): string {
  return tmpdir() + '/' + randomBytes(10).toString('hex') + '.' + ext
}
export async function toBuffer(str: string | Buffer) {
  if (!str)
    return {
      buffer: Buffer.alloc(0),
      ext: 'png',
      mimetype: 'image/png',
    }
  const buffer = Buffer.isBuffer(str) ? str : fs.existsSync(str) ? fs.readFileSync(str) : str.startsWith('http') ? await fetch(str).then(async (res) => await res.buffer()) : Buffer.from(str)
  const file = await filetype.fromBuffer(buffer)
  const fixbuffer = buffer instanceof ArrayBuffer ? Buffer.from(buffer) : buffer
  if (!file) throw new Error('Invalid file type')
  return {
    buffer: fixbuffer,
    mime: file.mime,
    ext: file.ext,
  }
}
export const expandUrl = async (url: string) => {
  let link: string
  try {
    const res = await axios({
      method: 'get',
      url: url,
      maxRedirects: 0,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Linux; Android 10; Redmi 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.58 Mobile Safari/537.36',
        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
      },
    })
    link = res.headers.location
  } catch (err) {
    if (Math.trunc(err.response.status / 100) === 3) {
      link = err.response.headers.location
    } else {
      throw err
    }
  } finally {
    return link
  }
}
export const dateFormat = (date: Date) => {
  const monthNames = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember']
  const day = date.getDate()
  const monthIndex = date.getMonth()
  const year = date.getFullYear()
  return `${day} ${monthNames[monthIndex]} ${year}`
}
export const to1k = (num: number) => {
  return num > 999 ? `${(num / 1000).toFixed(1)}k` : num
}
export const isUrl = (str: string): string | null => {
  const pattern = new RegExp(
    '^(https?:\\/\\/)?' + // protocol
      '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|' + // domain name
      '((\\d{1,3}\\.){3}\\d{1,3}))' + // OR ip (v4) address
      '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' + // port and path
      '(\\?[;&a-z\\d%_.~+=-]*)?' + // query string
      '(\\#[-a-z\\d_]*)?$',
    'i'
  ) // fragment locator
  return pattern.test(str) ? str.match(pattern)[0] : null
}
export const undoFormatedSize = (size: string) => {
  const num = Number(size.split(/[^0-9\.]+/g)[0])
  const unit = size.replace(/[^a-zA-Z]/g, '')
  switch (unit) {
    case 'KB':
      return num * 1000
    case 'MB':
      return num * 1000000
    case 'GB':
      return num * 1000000000
    case 'TB':
      return num * 1000000000000
    default:
      return num
  }
}
